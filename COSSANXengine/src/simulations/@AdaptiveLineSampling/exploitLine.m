function [Xobj,Tline,XpartialSimOut] = exploitLine(Xobj,Xtarget,varargin)
% EXPLOIT LINE
% Locate the point on the limit state for a simulated direction, starting
% from any point in the space, and collect all relevant information
% regarding the line.

% See also: https://cossan.co.uk/wiki/index.php/sample@AdaptiveLineSampling
%
% Author:~Marco~de~Angelis
% Institute for Risk and Uncertainty, University of Liverpool, UK
%% Validate input arguments
OpenCossan.validateCossanInputs(varargin{:});

% Initialise vector to store performance values
VgStore=NaN(1,Xobj.NmaxPoints);
% Initialise vector to store line distances
VdStore=NaN(1,Xobj.NmaxPoints);
% Initialise vector to store line's point norm
VnStore=NaN(1,Xobj.NmaxPoints);

% initialise variables
Valpha=Xobj.Valpha;
VinitialDistance=0;
iLine=0;
lineIndex=0;
for k=1:2:length(varargin)
    switch (lower(varargin{k}))
        case 'reliabilityindex'
            reliabilityIndex = varargin{k+1};
        case 'valpha'
            Valpha = varargin{k+1};
        case {'vhyperplanepoint'}
            % Coordiantes of the point where the line originates from. In 
            % LineSampling it lies on the orthogonal hyperplane to the 
            % important direction.In AdvancedLineSampling the line does 
            % not originate from this point, but still it is a mandatory 
            % point for the  method construction.
            VhyperPlanePoint = varargin{k+1};
        case {'vinitialdistance','startingdistance'}
            % This is the distance of the first evaluation point from the
            % orthogonal hyper plane.
            VinitialDistance = varargin{k+1};
        case {'linenumber','line'}
            % Current line
            iLine = varargin{k+1};
        case 'lineindex'
            % Current line index
            lineIndex = varargin{k+1};
        otherwise
            % error, unknown property specified
            error('OpenCossan:AdaptiveLineSampling:exploitLine',...
                ['Field name (' varargin{k} ') not allowed']);
    end
end

% Make sure the important direction is a unit column vector
Valpha=Valpha(:)/norm(Valpha);

% % keep the original important direction
% Valpha0=Valpha;

% % Make sure reliabilityIndex is not empty
% if isempty(Xobj.reliabilityIndex)
%     reliabilityIndex=NaN;
% else
%     reliabilityIndex=Xobj.reliabilityIndex;
% end

% Make sure VlineHyperPlanePoint is a column vector
VhyperPlanePoint=VhyperPlanePoint(:);


% Evaluate points coordinates. The number of columns of this matrix-array
% must be equal to the number of random variables.
MlinePoints=transpose(repmat(VhyperPlanePoint,1,length(VinitialDistance))+...
    Valpha*VinitialDistance);


% Perform Line Search
if isa(Xobj,'AdaptiveLineSampling') || isa(Xobj,'LineSampling') && iLine == 0
    
    [stateFlag,reliabilityIndex,distanceLimitState,VgLine,VlineDistances,...
        Valpha,ValphaNew,VstatePoint,LdirectionalUpdate,XpartialSimOut]...
        =...
        lineSearch(Xobj,...
        'Xtarget',Xtarget,...
        'reliabilityIndex',reliabilityIndex,...
        'VinitialDistance',VinitialDistance,...
        'VhyperplanePoint',VhyperPlanePoint,...
        'Valpha',Valpha,...
        'MlinePoints',MlinePoints,...
        'iLine',iLine,...
        'Salgorithm','NewtonRaphson');
    
elseif class(Xobj,'LineSampling')
    
    [stateFlag,reliabilityIndex,distanceLimitState,VgLine,VlineDistances,...
        Valpha,ValphaNew,VstatePoint,LdirectionalUpdate,XpartialSimOut]...
        =...
        lineSearch(Xobj,...
        'Xtarget',Xtarget,...
        'reliabilityIndex',reliabilityIndex,...
        'VinitialDistance',VinitialDistance,...
        'VhyperplanePoint',VhyperPlanePoint,...
        'Valpha',Valpha,...
        'MlinePoints',MlinePoints,...
        'iLine',iLine,...
        'Salgorithm','SplineFitting');
    
end
%% Store (and save) results of the analysis

% store line's results by adding a row in the following matrix
VlineResults=[iLine,...
    lineIndex,...
    distanceLimitState,...
    reliabilityIndex,...
    LdirectionalUpdate,...
    stateFlag,...
    Xobj.ibatch];

fid = fopen(fullfile(Xobj.StempPath,'mlineresults.txt'), 'a');
fprintf(fid, '\n %i %i %g %g %i %i %i', VlineResults);
fclose(fid);

% store a text file for information on the mlineresults.txt file
if iLine == 0
    SlineInfo='line number,  line index,  hyperplane-boundary distance,  directional update,  state flag,  batch number';
    fid = fopen(fullfile(Xobj.StempPath,'mlineresultsinfo.txt'), 'a');
    fprintf(fid, SlineInfo);
    fclose(fid);
elseif iLine==1
    SlineInfo='line number,  line index,  hyperplane-boundary distance,  directional update,  state flag,  batch number';
    fid = fopen(fullfile(Xobj.StempPath,'mlineresultsinfo.txt'), 'a');
    fprintf(fid, SlineInfo);
    fclose(fid);
end

% collect results from the current line 
Tline=struct('iLine',iLine,'lineIndex',lineIndex,...
    'distanceLimitState',distanceLimitState,...
    'reliabilityIndex',reliabilityIndex,...
    'LdirectionalUpdate',LdirectionalUpdate,...
    'stateFlag',stateFlag,'iBatch',Xobj.ibatch);


% specify here the precision for storing results in the text file 
SstringFormat=Xobj.makeString4TextFile('%1.12e',length(VgStore));

iend=length(VgLine);
% store performance values
VgStore(1:iend)=VgLine;
% store values in a text file
fid = fopen(fullfile(Xobj.StempPath,'mperformancevalues.txt'), 'a');
fprintf(fid, SstringFormat, VgStore(:)');
fclose(fid);
Tline.Vg=VgLine;

% store line distance values
VdStore(1:iend)=VlineDistances;
% store values in a text file
fid = fopen(fullfile(Xobj.StempPath,'mlinedistances.txt'), 'a');
fprintf(fid, SstringFormat, VdStore(:)');
fclose(fid);
Tline.Vdistances=VlineDistances;

% VnStore(1:iend)=V;


SstringFormat=Xobj.makeString4TextFile('%1.12e',length(VhyperPlanePoint));

% store coordinates of hyperplane points in a text file
fid = fopen(fullfile(Xobj.StempPath,'mhyperplanecoords.txt'), 'a');
fprintf(fid, SstringFormat, VhyperPlanePoint(:)');
fclose(fid);
Tline.VhyperPlanePoint=VhyperPlanePoint;

% store coordinates of the limit state points
fid = fopen(fullfile(Xobj.StempPath,'mlimitstatecoords.txt'), 'a');
fprintf(fid, SstringFormat, VstatePoint(:)');
fclose(fid);
Tline.VstatePoint=VstatePoint;

% store coordinates of the important direction
fid = fopen(fullfile(Xobj.StempPath,'mimportantdirections.txt'), 'a');
fprintf(fid, SstringFormat, ValphaNew(:)');
fclose(fid);
Tline.Valpha=Valpha;
Tline.ValphaNew=ValphaNew;

end