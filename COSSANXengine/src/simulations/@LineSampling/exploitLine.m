function [Xobj,LupdateDirection,XlineSamplingData]=...
    exploitLine(Xobj,Xtarget,varargin)
%EXPLOIT LINE
%Locate the point on the limit state for a simulated direction, starting
%from any point in the space, and collect all the important information
%regarding the line.
% Note that in LineSampling this method performs only on the zero-line,
% i.e. the line passing through the origin.

% See also: https://cossan.co.uk/wiki/index.php/sample@LineSampling
%
% Author: Marco de Angelis
% Institute for Risk and Uncertainty, University of Liverpool, UK
% email address: openengine@cossan.co.uk
% Website: http://www.cossan.co.uk

%% Validate input arguments
OpenCossan.validateCossanInputs(varargin{:});
% Check inputs
[Xobj,Xinput]=checkInputs(Xobj,Xtarget);

% Parameters of the LineSearch algorithm
VinitialDistance=0;
iLine=0;
acceptableError=1e-4; %accepted error on the performance function values
tolerance=1e-4; %smallest step size allowed for iterations
minStep=0.5; %step size to move along the lines
NmaxPoints=10; %maximum number of evaluation points to identify the boundary

for k=1:2:length(varargin)
    switch (lower(varargin{k}))
        case {'vlinehyperplanepoint'}
            % This is the point where the line originates from. In 
            % LineSampling it lies on the orthogonal hyperplane to the 
            % important direction. In RadialLineSampling it is simply the 
            % origin. In AdvancedLineSampling the line does not originate
            % from this point, but still it is a mandatory point for the 
            % method construction.
            % In VlineHyperPlanePoint are stored the coordinates of such
            % point in the standard normal space.
            VlineHyperPlanePoint = varargin{k+1};
        case {'vinitialdistance','startingdistance'}
            % This is the distance of the first evaluation point from the
            % orthogonal hyper plane.
            VinitialDistance = varargin{k+1};
        case {'linenumber','line'}
            % Current line
            iLine = varargin{k+1};
        otherwise
            % error, unknown property specified
            error('OpenCossan:AdvancedLineSampling:exploitLine',...
                ['Field name (' varargin{k} ') not allowed']);
    end
end

assert(~isempty(Xobj.Valpha),...
    'openCOSSAN:Simulations:LineSampling',...
    'The important direction is mandatory for this method');

assert(logical(exist('VlineHyperPlanePoint','var')), ...
    'openCOSSAN:Simulations:LineSampling',...
    'The point on the orthogonal hyper plane is mandatory')

% Normalise important direction
Valpha=Xobj.Valpha/norm(Xobj.Valpha);

% Make sure Valpha is a column vector
Valpha=Valpha(:);
Valpha0=Valpha;

% Make sure reliabilityIndex is not empty
if isempty(Xobj.reliabilityIndex)
    reliabilityIndex=NaN;
else
    reliabilityIndex=Xobj.reliabilityIndex;
end 

% Make sure VlineHyperPlanePoint is a column vector
VlineHyperPlanePoint=VlineHyperPlanePoint(:);

% Reset Variables
Xs=[]; % initialise Samples object
XpartialSimOut=[]; % initialise Simulation Data object

% Start collecting the distances on the line, starting from the distance of
% the first evaluation point
ClineDistances=cell(1,NmaxPoints);
ClineDistances{1}=VinitialDistance;
VlineDistances=cell2mat(ClineDistances);

% Initialise variables
distanceLimiState=0;
VmagicPoint=NaN(size(VlineHyperPlanePoint));
LupdateDirection=false;

% Initialise state conditions for the loop over the points
LprocessingAccomplished=false; %this turns true when the state boundary is met
LstateNotFound=false; % this turns true when anywhere on the given direction the state boundary is not met
LkeepLooping=true; % this turns false when it is no longer needed to loop

% Evaluate points coordinates. The number of columns of this matrix-array
% must be equal to the number of random variables.
Mpoints=transpose(repmat(VlineHyperPlanePoint,1,length(VinitialDistance))+...
    Valpha*VinitialDistance);

iPoint=0;
while LkeepLooping
    
    iPoint=iPoint+1; % count the number of points
    
    % Check if one of the points is out of the hypercube
    if any(any(Mpoints>8))
        % Take the point along the line to the edge of the hypercube
        for iSamplePoint=1:size(Mpoints,1)
            if any(Mpoints(iSamplePoint,:)>8)
                % Compute the point on the line that meets the edge of the
                % hypercube
                [~,b]=max(Mpoints(iSamplePoint,:));
                ratio=(8-VlineHyperPlanePoint(b))/Valpha(b);
                VhypercubeEdgePoint=VlineHyperPlanePoint+ratio*Valpha;
                Mpoints(iSamplePoint,:)=VhypercubeEdgePoint';
                
            end
        end
    end
    
    % Gererate samples (define starting point of the lines)
    Xsamples=Samples('MsamplesStandardNormalSpace',Mpoints,'Xinput',Xinput);
    
    % Collect samples
    if ~isempty(Xs)
        Xs=Xs.add('Xsamples',Xsamples);
    else
        Xs=Xsamples;
    end
    
    % Evaluate the model
    XlineSimOut= apply(Xtarget,Xsamples);
    
    % Collect Outputs
    if ~isempty(XpartialSimOut)
        XpartialSimOut=XpartialSimOut.merge(XlineSimOut);
    else
        XpartialSimOut=XlineSimOut;
    end
    
    % Extract the values of the performance function
    VgLine=XpartialSimOut.getValues('Sname',Xtarget.XperformanceFunction.Soutputname);
    
    
    if any(abs(VgLine)<acceptableError) 
        
        [~, imin]=min(abs(VgLine));
        currentLineDistance=VlineDistances(imin);
        distanceLimiState=currentLineDistance;
        
        % Store magic point coordinates in a vector array
        VmagicPoint=VlineHyperPlanePoint+distanceLimiState*Valpha;
        
        if ~isnan(reliabilityIndex)
            % check if a new reliability index is found
            if norm(VmagicPoint)+1e-4 < reliabilityIndex
                reliabilityIndex=norm(VmagicPoint);
                Valpha = VmagicPoint/norm(VmagicPoint);
                LupdateDirection=true;
            end
        end
        
        if length(VgLine)==1
            stateFlag=0; % State boundary met at first attempt
            OpenCossan.cossanDisp(strcat('Intersection found at first attempt on Line#: ',...
                num2str(iLine)),2)
        elseif sign(VgLine(1))==1 && sign(distanceLimiState)==1
            stateFlag=1; % State boundary met regularly after some iterations
        elseif sign(VgLine(1))==1 && sign(distanceLimiState)==-1
            stateFlag=2; % State boundary met after some iterations on the direction opposite to Valpha
        elseif sign(VgLine(1))==-1 && sign(distanceLimiState)==1
            stateFlag=1; % State boundary met regularly after some iterations
        elseif sign(VgLine(1))==-1 && sign(distanceLimiState)==-1
            stateFlag=2; % State boundary met on the negative half-space on the direction opposite to Valpha
        else
            stateFlag=5; % State boundary exists but has a complex topology
        end
        
        if stateFlag==2 && iLine==0
            % An update in direction is needed
            Valpha = VmagicPoint/norm(VmagicPoint);
            LupdateDirection=true;
            OpenCossan.cossanDisp('Intersection met the wrong way round! Consider changing sign to the important direction.',2)
        end
        
        LprocessingAccomplished=true; % Point close enough to the limit state function
    end
    
    % Evaluate the increment for the next iteration
    if length(VgLine)==1 
        x = minStep*sign(VgLine);
        currentLineDistance=VlineDistances+x;
    else
        % Use the slope of the performance function between two
        % points to move in bigger(smaller) steps (quasi-Newton method)
        
        % Pick the last two evaluated points
        VgLastTwo=[VgLine(end-1),VgLine(end)];
        VlineLastTwo=[VlineDistances(end-1),VlineDistances(end)];
        [~,posMinVg]=min(abs(VgLastTwo));
        
        % dx= - f[x] / f'[x]
        x = - VgLastTwo(posMinVg)/...
            ((VgLine(end)-VgLine(end-1))/(VlineLastTwo(2)-VlineLastTwo(1)));
        
        if isnan(x) && abs(VgLine(end))<=acceptableError
            x=0;
        elseif isnan(x)
            x = minStep*sign(VgLine);
        end
        currentLineDistance=VlineLastTwo(posMinVg)+x;
    end
    
    %Check if any point goes beyond the hypercube, if so get the line point
    %on the edge of the hypercube, and restart from a middle random value
    if norm((VlineHyperPlanePoint+Valpha*currentLineDistance),Inf)>8
        % evaluate point on the edge of the hypercube
        [~,b]=max(VlineHyperPlanePoint+Valpha*currentLineDistance);
        ratio=(8-VlineHyperPlanePoint(b))/Valpha(b);
        VhypercubeEdgePoint=VlineHyperPlanePoint+ratio*Valpha;
        
        if sign(currentLineDistance)==1
            %restart from a random point close to the edge of
            %the hypercube
            currentLineDistance=(20+rand)/21*...
                norm(VhypercubeEdgePoint-VlineHyperPlanePoint);
        else
            % restart from a random point anywhere in between
            currentLineDistance=rand*...
                norm(VhypercubeEdgePoint-VlineHyperPlanePoint);
        end
    end
    
    % Check if the intersection has been found
    if (abs(sum(sign(VgLine)))<length(VgLine)) && ~LprocessingAccomplished
        % Compute the point on the limit state by interpolating among the 
        % available points
        VlineDistanceFine=linspace(min(VlineDistances),...
            max(VlineDistances),Xobj.Ncfine);
        VgFine=interp1(VlineDistances,VgLine,VlineDistanceFine,'spline');
        
        % get the closest point to the boundary
        [~,posMinVgFine]=min(abs(VgFine));
        distanceLimiState=VlineDistanceFine(posMinVgFine);

        % Check if the points are close enough to the estimeted
        % point for the limit state function
        if abs(x)<=tolerance || length(VgLine)==NmaxPoints
            % store point coordinates in a vector array
            VmagicPoint=VlineHyperPlanePoint+distanceLimiState*Valpha;
            
            if ~isnan(reliabilityIndex)
                % check if a new reliability index is found
                if norm(VmagicPoint)+1e-4 < reliabilityIndex
                    reliabilityIndex=norm(VmagicPoint);
                    Valpha = VmagicPoint/norm(VmagicPoint);
                    LupdateDirection=true;
                end
            end

            % Assign the state flags
            if sign(VgFine(1))==1 && sign(distanceLimiState)==1
                stateFlag=1; % State boundary met regularly after some iterations
            elseif sign(VgFine(1))==1 && sign(distanceLimiState)==-1
                stateFlag=2; % State boundary met after some iterations on the direction opposite to Valpha
            elseif sign(VgFine(1))==-1 && sign(distanceLimiState)==1
                stateFlag=1; % State boundary met after some iterations
            elseif sign(VgFine(1))==-1 && sign(distanceLimiState)==-1
                stateFlag=2; % State boundary met on the negative half-space
            else
                stateFlag=5; % State boundary exists but has a complex topology
            end
            
            LprocessingAccomplished=true; % intersection with limit state function discovered
        end
    end
    
    % Check if the maximum number of points has been reached
    if abs(sum(sign(VgLine)))==NmaxPoints
        
        if iLine==0
            OpenCossan.cossanDisp('Intersection not met on the line passing through the origin',2)
        else
            OpenCossan.cossanDisp(strcat('Intersection not met on Line#: ',...
                num2str(iLine)),2)
        end
       
        if sign(VgLine(1))
            stateFlag=3; % State boundary not met, the whole line is in the safe domain
        else
            stateFlag=4; % State boundary not met, the whole line is in the failed domain
        end
        LstateNotFound=true; % state function NOT found
        
    elseif length(VgLine)==NmaxPoints
        
        if iLine==0
            OpenCossan.cossanDisp(...
                sprintf('Intersection on the line passing through the origin found with less accuracy than specified.\n May want to increase the number of evaluation points currently set to %i',...
                NmaxPoints),2)
        else
            OpenCossan.cossanDisp(...
                sprintf('The intersection on Line#: %d was found with less accuracy than specified.',...
                iLine),2)
        end
        
    end
    
    % Evaluate points coordinates
    Mpoints=transpose(VlineHyperPlanePoint+Valpha*currentLineDistance);
    
    % Condition for getting out of the loop
    if LprocessingAccomplished
        LkeepLooping=false;
    elseif LstateNotFound
        LkeepLooping=false;
    else
        % Store current distance
        ClineDistances{iPoint+1}=currentLineDistance;
        VlineDistances=cell2mat(ClineDistances);
    end
    
end %loop over points of the line

% Create Line Sampling Data object to collect information on the current
% line
XlineSamplingData = LineSamplingData(...
    'SperformanceFunctionName',Xtarget.XperformanceFunction.Soutputname,...
    'VperformanceValues',VgLine',...
    'VlineHyperPlanePoint',VlineHyperPlanePoint,...
    'VlineDistances',VlineDistances,...
    'XsimulationData',XpartialSimOut,...
    'VstatePoint',VmagicPoint,...
    'VimportantDirection',Valpha0,...
    'distanceLimitState',distanceLimiState,...
    'iLine',iLine,...
    'LupdateDirection',LupdateDirection,...
    'reliabilityIndex',reliabilityIndex,...
    'stateFlag',stateFlag,...
    'lineIndex',iLine,...
    'Xinput',Xinput,...
    'Xsimulator',Xobj);

end